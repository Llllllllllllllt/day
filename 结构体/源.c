#include<stdio.h>
//int counta(int a) {
//	//这是第一种方法
//	int count = 0;
//	while(a > 0) {
//		if (a % 2 == 1) {
//			count++;
//		}
//		a = a / 2;
//	}
//采取%2，/2的形式进行判断，适用于正数，
//如果是负数的话由于这里的负数是以补码的形式存在的
//要先将负数进行无符号转换，转换成无符号的二进制形式再进行比
//	return count;
//}
//
//int counta(int a) {
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++) {
//		if (((a >> 1) & 1) == 1) {
//			count++;
//		}//这里通过右移操作符将数字的二进制按位与1
//		//得到的结果等于1时，就会进行计入
//		//也就可以计算-1的二进制补码有多少个1了
//		//而第一种方法不可以这样，因为负数在进行计算时
//		//进行原码到反码再到补码的转换，这时候单单使用
//		//%2，/2的形式是不行的,要进行无符号转换。
//		//而这种方式就会循环32次。
//	}
//	return count;
//}
int counta(int a) {
	int count = 0;
	while (a) {
		a=a& (a - 1);
		count++;
		}
	return count;
}
//这里的a按位与a-1，就是减去了a二进制形式的一个一，
//如果a是15，二进制是1111，那么a按位与1110，就会为1110，
//之后再1110与1101按位与变成了1100，注意:少的是二进制的一
//之后1100与1011按位与就变成了1000；1000与0111按位与就变成
//了0000，此时就变成了0，结束循环
//这种算法的有优点是十分精练，对于给定的数字，数字的二进制
//中有几个1，就会进行多少次，没有多余的运算。
int difference(int a,int b) {
	int c = a ^ b;
	return c;

}
void oddandeven(int a) {//③
	int i = 0;
	printf("奇数位: \n");//开始打印奇数位
	for (i = 30; i >= 0; i-=2) {
		printf("%d", (a >> i) & 1);
	}//从左开始打印，所以第一个移动30个，就是31的位置
	//然后按位与1就能够获得这一位是1还是0.
	printf("\n");
	printf("偶数位: \n");//开始打印偶数位
	for (i = 31; i >= 1; i -= 2) {
		printf("%d", (a >> i) & 1);
	}
}
int main() {
	//①判断一个数字的二进制形式中有几个一
	
	int a = 0;
	int b = 0;
	scanf("%d%d", &a,&b);
	int c = difference(a, b);
	int count = counta(c);
	printf("count  = %d\n", count);
	int m = 0;
	scanf("%d", &m);
	oddandeven(m);
	system("pause");//system库函数，执行系统命令-pause暂停

	//②另一道题判断两个数字在二进制中有几位不同。
	//这里的二进制无非就是1或者0，
	//将两个数字的二进制按位或，打出的一个新的量上面
	//有几个一就有几为不同，
	//接下来就再进行上面第一题的函数，计算得到的量的一的个数


	//③第三道题就是打印出一个数字的二进制的所有奇数位
	//和偶数位。
	


	return 0;
}
